https://downloads.mongodb.org/win32/mongodb-shell-win32-x86_64-2008plus-ssl-4.0.6.zip
mongo "mongodb+srv://cluster0-3nksr.mongodb.net/test" --username testuser
mongodb+srv://testuser:<PASSWORD>@cluster0-3nksr.mongodb.net/test?retryWrites=true
mongo "mongodb+srv://cluster0-3nksr.mongodb.net/test" --username testuser

mongoose.connect(process.env.DATABASE, { useNewUrlParser: true }); ???

new modules - jsonwebtoken for athentication
const bcrypt = require('bcryptjs'); - for hashing passwords

routes and handles folder
2 routes - authentication & poll

router
  .route('/')
  .get(handle.showPolls)
  .post(auth, handle.createPoll);
  
  
  authentcation routes
  --------------------
  router.get('/', handle.getUsers); // for development only
router.post('/login', handle.login);
router.post('/register', handle.register);

poll routes
--------------
router
  .route('/')
  .get(handle.showPolls)
  .post(auth, handle.createPoll);

router.get('/user', auth, handle.usersPolls);

router
  .route('/:id')
  .get(handle.getPoll)
  .post(auth, handle.vote)
  .delete(auth, handle.deletePoll);
  
  Createpoll
  ----------------
exports.createPoll = async (req, res, next) => {
  const { id } = req.decoded;
  const { question, options } = req.body;
  try {
    const user = await db.User.findById(id);
    const poll = await db.Poll.create({
      question,
      user,
      options: options.map(option => ({ option, votes: 0 })),
    });
    user.polls.push(poll._id);
    await user.save();

    return res.status(201).json({ ...poll._doc, user: user._id });
  } catch (err) {
    return next({
      status: 400,
      message: err.message,
    });
  }
};  



user registration & login
--------------------
exports.register = async (req, res, next) => {
  try {
    const user = await db.User.create(req.body);
    const { id, username } = user;
    const token = jwt.sign({ id, username }, process.env.SECRET);

    return res.status(201).json({
      id,
      username,
      token,
    });
  } catch (err) {
    if (err.code === 11000) {
      err.message = 'Sorry, that username is already taken';
    }
    return next({
      status: 400,
      message: err.message,
    });
  }
};

exports.login = async (req, res, next) => {
  try {
    const user = await db.User.findOne({
      username: req.body.username,
    });
    const { id, username } = user;
    const valid = await user.comparePassword(req.body.password);

    if (valid) {
      const token = jwt.sign({ id, username }, process.env.SECRET);
      return res.status(200).json({
        id,
        username,
        token,
      });
    } else {
      throw new Error();
    }
  } catch (err) {
    return next({ status: 400, message: 'Invalid Username/Password' });
  }
};



model:
-----------
const optionSchema = new mongoose.Schema({
  option: String,
  votes: {
    type: Number,
    default: 0,
  },
});

const pollSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
  },
  created: {
    type: Date,
    default: Date.now,
  },
  question: String,
  options: [optionSchema],
  voted: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
});